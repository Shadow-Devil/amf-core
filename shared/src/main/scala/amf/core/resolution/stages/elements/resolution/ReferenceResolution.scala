package amf.core.resolution.stages.elements.resolution
import amf.core.annotations._
import amf.core.metamodel.document.DocumentModel
import amf.core.model.document.Document
import amf.core.model.domain.{DomainElement, LinkNode, NamedDomainElement, Linkable}
import amf.core.parser.{Annotations, ErrorHandler}
import amf.core.resolution.stages.{ModelReferenceResolver, LinkNodeResolutionStage, LinkNodeResolver, ResolvedNamedEntity}
import amf.core.vocabulary.Namespace

import scala.collection.mutable

class ReferenceResolution(cache: mutable.Map[String, DomainElement] = mutable.Map(),
                          keepEditingInfo: Boolean,
                          modelResolver: Option[ModelReferenceResolver],
                          errorHandler: ErrorHandler,
                          customDomainElementTransformation: (DomainElement, Linkable) => DomainElement =
                            (d: DomainElement, l: Linkable) => d)
    extends ElementStageTransformer[DomainElement] {

  private def isValidDeclaration(element: DomainElement, target: DomainElement): Boolean = {
    element.annotations.contains(classOf[DeclaredElement]) && !target.isInstanceOf[ErrorDeclaration]
  }

  override def transform(element: DomainElement): Option[DomainElement] = {
    element match {
      case l: Linkable if l.linkTarget.isDefined =>
        if (cache.contains(l.linkTarget.get.id)) Some(cache(l.linkTarget.get.id))
        else {
          val target = l.effectiveLinkTarget() match {
            case t: DomainElement if cache.contains(t.id) => cache(t.id)
            case t: DomainElement with Linkable if isValidDeclaration(element, t) =>
              val copied =
                t.copyElement(t.annotations.copy().reject(_.isInstanceOf[AutoGeneratedName])).withId(element.id)
              element match {
                case n: NamedDomainElement if n.name.option().isDefined =>
                  copied.asInstanceOf[NamedDomainElement].withName(n.name.value(), n.name.annotations())
                case _ => // ignore
              }
              copied
            case d: DomainElement =>
              propagateAnnotations(l, d)
              d
          }
          val resolved = innerLinkNodeResolution(target)
          resolved match {
            case linkable: Linkable if l.supportsRecursion.option().getOrElse(false) =>
              linkable.withSupportsRecursion(true)
            case _ => // ignore
          }
          val resolved2 = customDomainElementTransformation(withName(resolved, l), l)

          resolved2.annotations += ResolvedInheritance()
          if (keepEditingInfo) {
            resolved2.annotations += ResolvedLinkAnnotation(l.id)
            l.linkTarget.map { linkTarget =>
              resolved2.annotations += ResolvedLinkTargetAnnotation(linkTarget.id)
            }
          }
          traverseLinks(element, resolved2)
          Some(resolved2)
        }
      case ln: LinkNode => LinkNodeResolver.resolveDynamicLink(ln, modelResolver, keepEditingInfo)
      case _            => None
    }
  }

  private def propagateAnnotations(link: DomainElement, element: DomainElement): Unit = {
    link.annotations.find(classOf[TrackedElement]).foreach {
      case t @ TrackedElement(values) =>
        val tracked = element.annotations
          .find(classOf[TrackedElement])
          .fold(t)(inner => TrackedElement(values ++ inner.parents))

        element.annotations.reject(_.isInstanceOf[TrackedElement])
        element.add(tracked)
    }
    if (link.annotations.contains(classOf[AutoGeneratedName]) && !element.annotations.contains(
          classOf[DeclaredElement]))
      element.add(AutoGeneratedName())
  }

  // Links traversion to expand annotations and add links to 'cache'
  @scala.annotation.tailrec
  private def traverseLinks(element: DomainElement,
                            resolved: DomainElement,
                            visited: mutable.Set[String] = mutable.Set()): Unit = {
    if (!visited.contains(element.id)) {
      visited += element.id
      element match {
        case l: Linkable if l.linkTarget.isDefined =>
          adoptParentAnnotations(element.annotations, resolved)
          if (element.annotations.contains(classOf[DeclaredElement])) cache.put(element.id, resolved)
          traverseLinks(l.linkTarget.get, resolved, visited)
        case _ => // nothing to do
      }
    }
  }

  private def adoptParentAnnotations(parentAnnotations: Annotations, child: DomainElement): Unit = {
    parentAnnotations.foreach { a =>
      // Only annotation DeclaredElement is added
      if (a.isInstanceOf[DeclaredElement] && !child.annotations.contains(a.getClass)) child.annotations += a
    }
  }

  private def innerLinkNodeResolution(target: DomainElement): DomainElement = {
    val nested = Document()
    nested.fields.setWithoutId(DocumentModel.Encodes, target)
    val result = new LinkNodeResolutionStage(keepEditingInfo)(errorHandler).resolve(nested)
    result.asInstanceOf[Document].encodes
  }

  private def withName(resolved: DomainElement, source: DomainElement): DomainElement = {
    resolved match {
      case r: NamedDomainElement =>
        if (isExample(r)) {
          source match {
            case s: NamedDomainElement if s.name.option().isDefined =>
              r.withName(s.name.value(), r.name.annotations())
            case _ =>
          }
        } else if (r.name.option().isEmpty || r.name.value() == "schema" || r.name.value() == "type" || r.name
                     .value() == "body" || r.annotations.contains(classOf[AutoGeneratedName])) {
          source match {
            case s: Linkable => innerName(s, r)
            case _           =>
          }
        }
      case _ =>
    }
    // let's annotate the resolved name
    source match {

      case s: NamedDomainElement if s.name.nonEmpty =>
        val resolvedNamesPresent          = resolved.annotations.find(classOf[ResolvedNamedEntity])
        val resolvedNamedEntityAnnotation = resolvedNamesPresent.getOrElse(ResolvedNamedEntity())
        val referenced                    = resolvedNamedEntityAnnotation.vals.getOrElse(s.name.value(), Nil)
        resolvedNamedEntityAnnotation.vals.put(s.name.value(), referenced ++ Seq(s))
        if (resolvedNamesPresent.isEmpty)
          resolved.annotations += resolvedNamedEntityAnnotation

      case s: Linkable if s.isInstanceOf[NamedDomainElement] && s.linkLabel.option().isDefined =>
        val resolvedNamesPresent          = resolved.annotations.find(classOf[ResolvedNamedEntity])
        val resolvedNamedEntityAnnotation = resolvedNamesPresent.getOrElse(ResolvedNamedEntity())
        val referenced                    = resolvedNamedEntityAnnotation.vals.getOrElse(s.linkLabel.value(), Nil)
        resolvedNamedEntityAnnotation.vals
          .put(s.linkLabel.value(), referenced ++ Seq(s.asInstanceOf[NamedDomainElement]))
        if (resolvedNamesPresent.isEmpty)
          resolved.annotations += resolvedNamedEntityAnnotation

      case _ => // ignore
    }

    resolved
  }

  private def innerName(source: DomainElement with Linkable, resolved: DomainElement with NamedDomainElement): Unit =
    source match {
      case s: NamedDomainElement =>
        s.name.option() match {
          case Some(_) if s.annotations.contains(classOf[AutoGeneratedName]) => inner(source, resolved)
          case Some("schema" | "type" | "body") | None if source.isLink      => inner(source, resolved)
          case Some(other)                                                   => resolved.withName(other, resolved.name.annotations())
          case _                                                             =>
        }
      case _ =>
    }

  private def inner(source: DomainElement with Linkable, resolved: DomainElement with NamedDomainElement): Unit = {
    source.linkTarget match {
      case Some(target: Linkable) => innerName(target, resolved)
      case _                      =>
    }
  }

  /** Check if it is an example. Special case where NamedExample fragments are used from an 'example' facet. */
  private def isExample(r: DomainElement) =
    r.meta.`type`.headOption.contains(Namespace.Document + "Example")

}
